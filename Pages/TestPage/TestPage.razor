@page "/test-page"
@inject AppState appState

<div>
    <OneWayBinding WaterfallProp=@propOfOneWayBinding />
    <LiteralComponent Visible="true" Text="Truyền vào props giá trị bình thường" />
    <ExpressionComponent Visible=@expressionComponentVisible Text=@expressionComponentText />

    @*Callback events*@
    <CallbackComponent CallBackEvent="@OnSelectedBank" BankList="@bankList" />
    @if (selectedBank != null)
    {
        <p>Đã chọn @selectedBank.BankCode - @selectedBank.BankName <a @onclick="OnClearBank">Clear</a></p>
    }

    @*Test events*@
    <ul>
        <li>Last multiple of two = @LastMultipleOfTwo</li>
        <li>Last multiple of three = @LastMultipleOfThree</li>
    </ul>
    <Counter OnMultipleOfThree=@UpdateLastMultipleOfThreeValue OnMultipleOfTwoAction=@UpdateLastMultipleOfTwoValue />

    @*
        Two-way binding: naming convention
        @bind-CurrentCounterValue : cần có prameter CurrentCounterValue và event callback CurrentCounterValueChanged (tên bắt buộc phải ...Changed)
    *@
    <TwoWayBinding @bind-CurrentCounterValue="@currentCounterValue" />
    <Button Type="primary" @onclick="IncreaseFromParent">Increase From Parent</Button>

    @*Binding Directive*@
    <BindingDirective />

    @*Cascading value by name*@
    <CascadingValueByName />

    <Button Type="primary" @onclick="OnClickGet">Get</Button>
    @if (_data != null)
    {
        <p>page: @_data.Page - @_time</p>
    }
    @if (_data2 != null)
    {
        <p>page: @_data2.Page - @_time2</p>
    }
</div>

@code {
    private int propOfOneWayBinding = 123; // khởi tạo giá trị truyền vào cho OneWayBinding
    private bool expressionComponentVisible = true;
    private string expressionComponentText = "Truyền vào props dạng biểu thức thì thêm @ vào bên phải props";

    // Xử lý khi callback event
    public Bank[] bankList = { new Bank(1, "Vietcombank", "VCB"), new Bank(2, "AgriBank", "AGB"), new Bank(3, "Techcombank", "TCB") };
    private Bank selectedBank;
    private void OnSelectedBank(Bank bank)
    {
        Console.WriteLine(bank);
        selectedBank = bank;
    }
    private void OnClearBank()
    {
        selectedBank = null;
    }

    // Test events
    int LastMultipleOfTwo = 0;
    int LastMultipleOfThree = 0;
    private Task UpdateLastMultipleOfThreeValue(int value)
    {
        LastMultipleOfThree = value;
        return Task.CompletedTask;
    }
    private void UpdateLastMultipleOfTwoValue(int value)
    {
        LastMultipleOfTwo = value;
    }

    // Two-way binding handle
    private int currentCounterValue;
    private void IncreaseFromParent()
    {
        currentCounterValue++;
    }
    private ProductList _data;
    private ProductList _data2;
    private DateTime _time;
    private DateTime _time2;

    [Inject] protected IProductService ProductService { get; set; }
    async Task getSample()
    {
        await Task.Delay(1000);
        _data = await ProductService.GetCurrentProductAsync(1);
        _time = DateTime.Now;
        StateHasChanged();
    }
    async Task getSample2()
    {
        await Task.Delay(3000);
        _data2 = await ProductService.GetCurrentProductAsync(2);
        _time2 = DateTime.Now;
        StateHasChanged();
    }
    void OnClickGet()
    {
        var task1 = Task.Factory.StartNew(getSample);
        var task2 = Task.Factory.StartNew(getSample2);
        Task.WaitAll(task1, task2);        
    }
}
